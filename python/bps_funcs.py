#!/usr/bin/env python

import logging
import argparse
import os
import sys
import re
import pickle
import networkx
import subprocess
import shlex

from lsst.pipe.base.graph import QuantumGraph

try:
    from lsst.pipe.base.graph import QuantumGraphTaskNodes
except ImportError:
    from lsst.pipe.base.graph import QuantumGraphNodes

from daxgen import Daxgen


def read_qgraph(qgraph_filename):
    with open(qgraph_filename, 'rb') as pickleFile:
        qgraph = pickle.load(pickleFile)
    return qgraph

def make_single_qgnode(taskDef, quanta):
    try:
        qnode = QuantumGraphTaskNodes(taskDef, quanta)
    except NameError:
        qnode = QuantumGraphNodes(taskDef, quanta)
    return qnode

def save_single_qgnode(qgnode, outFilename):
    """Save single quantum to file

    Parameters
    ----------
    qgnode : QuantumGraph Node
        Single quantum to save
    outFilename : `str`
        Name of the output file
    """
    qgraph2 = QuantumGraph()
    qgraph2.append(qgnode)
    with open(outFilename, "wb") as pickleFile:
        pickle.dump(qgraph2, pickleFile)

def pretty_dataset_label(uniqName):
    newName = re.sub(r": ", "=", uniqName)
    newName = re.sub(r"\+", "\n", newName)
    newName = re.sub(r",", "\n", newName)
    newName = re.sub(r"[\{\}]", "", newName)
    return newName

def create_science_graph(qgraph):
    """Create expanded graph from the QuantumGraph that has explicit dependencies
    and has individual nodes for each input/output dataset

    Parameters
    ----------
    qgraph : QuantumGraph
        QuantumGraph for the pipeline (as generated by the QuantumGraph Generator)
    """
    logging.info("creating explicit science graph")

    sciGraph = networkx.DiGraph()
    ncnt = 0
    tcnt = 0
    dcnt = 0

    mapId = {}
    jobs = {}
    qgnodes = {}

    for taskId, nodes in enumerate(qgraph):
        logging.debug(taskId)
        taskDef = nodes.taskDef
        #logging.debug("dir=%s", dir(taskDef))
        logging.debug("config=%s", taskDef.config)
        logging.debug("taskClass=%s", taskDef.taskClass)
        logging.debug("taskName=%s", taskDef.taskName)
        logging.debug("label=%s",taskDef.label)
        for qId, quantum in enumerate(nodes.quanta):
            #logging.debug("dir=%s",dir(quantum))
            logging.debug('actualInputs=%s', quantum.actualInputs)
            logging.debug('id=%s',quantum.id)
            logging.debug('run=%s',quantum.run)
            logging.debug('task=%s',quantum.task)
            ncnt += 1
            tcnt += 1
            #tnodeName = "task%d (%s)" % (ncnt, taskDef.taskName)
            tnodeName = "%06d" % (ncnt)
            sciGraph.add_node(tnodeName, node_type=1, task_def_id=taskId, shape='box', fillcolor='gray',
                              style='"filled,bold"', label='.'.join(taskDef.taskName.split('.')[-2:]))
            quanta2 = [quantum]
            qgnodes[tnodeName] = make_single_qgnode(taskDef, quanta2)

            # Make nodes for inputs
            for dsRefs in quantum.predictedInputs.values():
                for dsRef in dsRefs:
                    #actualConsumers', 'components', 'dataId', 'datasetType', 'detach', 'id', 'isComposite', 'predictedConsumers', 'producer', 'run']
                    dsName = "%s+%s" % (dsRef.datasetType.name, dsRef.dataId)
                    if dsName not in mapId:
                        ncnt += 1
                        dcnt += 1
                        mapId[dsName] = ncnt
                    fnodeName = "%06d" % mapId[dsName]
                    fnodeDesc = pretty_dataset_label(dsName)
                    sciGraph.add_node(fnodeName, node_type=0, label=fnodeDesc, shape='box', style='rounded')
                    sciGraph.add_edge(fnodeName, tnodeName)

            # Make nodes for outputs
            for dsRefs in quantum.outputs.values():
                for dsRef in dsRefs:
                    dsName = "%s+%s" % (dsRef.datasetType.name, dsRef.dataId)
                    if dsName not in mapId:
                        ncnt += 1
                        dcnt += 1
                        mapId[dsName] = ncnt
                    fnodeName = "%06d" % mapId[dsName]
                    fnodeDesc = pretty_dataset_label(dsName)
                    sciGraph.add_node(fnodeName, node_type=0, label=fnodeDesc, shape='box', style='rounded')
                    sciGraph.add_edge(tnodeName, fnodeName)

    logging.info("tasks=%d files=%d", tcnt, dcnt)

    return sciGraph, qgnodes

def create_workflow_graph(args, sciGraph, qgnodes):
    """Create workflow graph from the Science Graph that has information
    needed for WMS (e.g., filenames, command line arguments, etc)

    Parameters
    ----------
    args :
        Command line arguments
    sciGraph : `networkx.DiGraph`
        Science Graph for the pipeline
    taskDefs : `dict`
        Dictionary of taskDefs
    """
    # modifying graph in place

    logging.info("creating workflow graph")
    ncnt = networkx.number_of_nodes(sciGraph)
    qcnt = 0
    nodelist = list(sciGraph.nodes())
    for nodename in nodelist:
        node = sciGraph.node[nodename]
        if node['node_type'] == 0:   # data/file
            node['lfn'] = nodename
            node['ignore'] = True
            node['data_type'] = "science"
        elif node['node_type'] == 1: # task  

            # add quantum pickle input data node
            ncnt += 1
            qcnt += 1
            qNodeName = "%06d" % ncnt
            qlfn = "quantum%s.pickle" % nodename
            if args.outdir is not None:
                qFileName = os.path.join(args.outdir, 'input', qlfn)

            lfn=os.path.basename(qFileName)
            sciGraph.add_node(qNodeName, node_type=0, lfn=lfn, label=lfn, pfn=qFileName,
                              ignore=False, data_type="quantum", shape='box', style='rounded')
            save_single_qgnode(qgnodes[nodename], qFileName)
            sciGraph.add_edge(qNodeName, nodename)

            node['exec_name'] = args.activator
            node['exec_args'] = args.actargs.format(qlfn=qlfn)
        else:
            raise ValueError("Invalid node_type (%s)" % node['node_type'])

def create_one_schema(cmdline):
    logging.info("schema creation cmdline = %s", cmdline)
    subprocess.run(shlex.split(cmdline), check=True)

def create_all_schemas(args, sciGraph, qgnodes):
    # Fill in variables for activator command line from args
    #   qlfn is filled in on a per activator basis later
    args.schargs = args.schargs.format(**vars(args),qlfn='{qlfn}')
    logging.info("schargs = '%s'", args.schargs)

    logging.info("creating schemas")
    schema_done = {}
    nodelist = list(sciGraph.nodes())
    for nodename in nodelist:
        node = sciGraph.node[nodename]
        if node['node_type'] == 1: # task  
            logging.debug("node = %s", node)
            if node['label'] not in schema_done:
                parents = list(sciGraph.predecessors(nodename))
                logging.debug("parents = %s", parents)
                for pnodename in parents:
                    pnode = sciGraph.node[pnodename]
                    logging.debug("pnode = %s", pnode)
                    if pnode['data_type'] == 'quantum':
                        create_one_schema(args.schargs.format(qlfn=pnode['pfn']))
                schema_done[node['label']] = True
